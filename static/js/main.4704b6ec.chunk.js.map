{"version":3,"sources":["components/GitHub-Mark-32px.png","components/Header.tsx","models/Note.ts","models/MockSyncedTable.ts","components/ServerNote.tsx","components/Server.tsx","components/ClientNote.tsx","components/Client.tsx","models/MockNetwork.ts","utility.ts","components/Network.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Header","className","href","src","githubMark","alt","newNote","text","updatedAt","Date","id","v1","toString","NotesDatabase","numberOfNotes","syncedAt","db","ix","add","rows","newKey","clone","map","r","Object","assign","this","keys","filter","includes","syncStamp","entity","originalKey","row","find","push","key","some","serverEntity","conflict","JSON","stringify","ServerNote","props","noteText","Server","useState","serverNotes","setServerNotes","noteComponents","note","strategyOptions","BASIC_CONFLICT_RESOLUTION_STRATEGIES","strategy","value","useEffect","syncRequest","serverDb","serverConfig","entityKey","entityLastUpdated","areEntitiesEqual","note1","note2","getServerEntities","getByKey","bind","getServerEntitiesSyncedSince","getSyncedSince","updateServerEntity","update","createServerEntity","conflictResolutionStrategy","resolutionStrategy","LeanSyncServer","sync","notes","lastSync","then","response","dispatch","type","catch","ex","onClick","onChange","e","target","ClientNote","classNames","Client","setLastSync","clientNotes","setClientNotes","noteIndex","updatedNotes","slice","updatedNote","syncResponse","clientDb","clientConfig","keySelector","getClientEntitiesRequiringSync","getRequiringSync","getClientEntities","getLastSyncStamp","a","async","markSyncStamp","updateEntity","createEntity","syncWithServer","entities","request","clientIndex","fakeResponse","newEntities","syncedEntities","conflictedEntities","Promise","resolve","LeanSyncClient","processSyncResponse","title","isOffline","console","log","initialNetwork","server","clients","mockNetworkReducer","network","action","modifiedNetwork","nw","setResolutionStrategy","addClient","splice","removeClient","setClientOffline","requestSync","client","respondSync","acknowledgeSync","val","Error","assertNever","Network","useReducer","mockNetwork","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.4704b6ec.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFNTE3OEEyQTk5QTAxMUUyOUExNUJDMTA0NkE4OTA0RCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFNTE3OEEyQjk5QTAxMUUyOUExNUJDMTA0NkE4OTA0RCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU1MTc4QTI4OTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU1MTc4QTI5OTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+m4QGuQAAAyRJREFUeNrEl21ojWEYx895TDPbMNlBK46IUiNmPvHBSUjaqc0H8pF5+aDUKPEBqU2NhRQpX5Rv5jWlDIWlMCv7MMSWsWwmb3tpXub4XXWdPHvc9/Gc41nu+nedc7/8r/99PffLdYdDPsvkwsgkTBwsA/PADJCnzX2gHTwBt8Hl7p537/3whn04XoDZDcpBlk+9P8AFcAghzRkJwPF4zGGw0Y9QS0mAM2AnQj77FqCzrtcwB1Hk81SYojHK4DyGuQ6mhIIrBWB9Xm7ug/6B/nZrBHBegrkFxoVGpnwBMSLR9EcEcC4qb8pP14BWcBcUgewMnF3T34VqhWMFkThLJAalwnENOAKiHpJq1FZgI2AT6HZtuxZwR9GidSHtI30jOrbawxlVX78/AbNfhHlomEUJJI89O2MqeE79T8/nk8nMBm/dK576hZgmA3cp/R4l9/UeSxiHLVIlNm4nFfT0bxyuIj7LHRTKai+zdJobwMKzcZSJb0ePV5PKN+BqAAKE47UlMnERELMM3EdYP/yrd+XYb2mOiYBiQ8OQnoRBlXrl9JZix7D1pHTazu4MoyBcnYamqAjIMTR8G4FT8LuhLsexXYYjICBiqhQBvYb6fLZIJCjPypVvaOoVAW2WcasCnL2Nq82xHJNSqlCeFcDshaPK0twkAhosjZL31QYw+1rlMpWGMArl23SBsZZO58F2tlJXmjOXS+s4WGvpMiBJT/I2PInZ6lIs9/hBsNS1hS6BG0DSqmYEDRlCXQrmy50P1oDRKTSegmNbUsA0zDMwRhPJXeCE3vWLPQMvan6X8AgIa1vcR4AkGZkDR4ejJ1UHpsaVI0g2LInpOsNFUud1rhxSV+fzC9Woz2EZkWQuja7/B+jUrgtIMpy9YCW4n4K41YfzRneW5E1KJTe4B2Zq1Q5EHEtj4U3AfEzR5SVY4l7QYQPJdN2as7RKBF0BPZqqH4VgMAMBL8Byxr7y8zCZiDlnOcEKIPmUpgB5Z2ww5RdOiiRiNajUmWda5IG6WbhsyY2fx6m8gLcoJDJFkH219M3We1+cnda93pfycZpIJEL/s/wSYADmOAwAQgdpBAAAAABJRU5ErkJggg==\"","import React from 'react'\r\n\r\nimport githubMark from './GitHub-Mark-32px.png'\r\nimport './Header.css'\r\n\r\nexport const Header = () => (\r\n    <header>\r\n        <div>\r\n            <h1 className='title is-1'>LeanSync Demo (Alpha)</h1>\r\n        </div>\r\n        <div>\r\n            <a href='https://github.com/NetsydeMiro/leansync'>\r\n                <img src={githubMark} className=\"App-logo\" alt=\"logo\" />\r\n                LeanSync Algorithm Repo\r\n            </a>\r\n            <br />\r\n            <a href='https://github.com/NetsydeMiro/leansync-demo'>\r\n                <img src={githubMark} className=\"App-logo\" alt=\"logo\" />\r\n                LeanSync Demo Repo\r\n            </a>\r\n        </div>\r\n    </header>\r\n)","import { v1 } from 'uuid'\r\n\r\nimport { MockSyncedTable } from './MockSyncedTable'\r\n\r\nexport interface Note {\r\n    id: string\r\n    text: string\r\n    updatedAt: Date\r\n    syncedAt?: Date\r\n}\r\n\r\nexport function newNote(text: string, updatedAt: Date = new Date()): Note {\r\n    return { id: v1().toString(), text, updatedAt }\r\n}\r\n\r\nexport class NotesDatabase extends MockSyncedTable<Note> {\r\n\r\n    static createPopulated(numberOfNotes: number, syncedAt: Date): NotesDatabase {\r\n        let db = new NotesDatabase()\r\n\r\n        for (let ix = 1; ix <= numberOfNotes; ix++) {\r\n            db.add(newNote(`Note ${ix}`, syncedAt), syncedAt)\r\n        }\r\n        return db\r\n    }\r\n}","import { v1 } from 'uuid'\r\n\r\nexport interface Entity {\r\n    id: any\r\n    updatedAt: Date\r\n    syncedAt?: Date\r\n    conflict?: string\r\n}\r\n\r\nexport interface KeyGenerator {\r\n    (): any\r\n}\r\n\r\n// TODO: refactor as dictionary instead of array of rows?\r\nexport class MockSyncedTable<EntityType extends Entity> {\r\n\r\n    constructor(\r\n        rows: Array<EntityType> = [],\r\n        public newKey: KeyGenerator = () => v1().toString()) {\r\n        this.rows = this.clone(rows)\r\n    }\r\n\r\n    rows: Array<EntityType>\r\n\r\n    protected clone = (rows: Array<EntityType>) => rows.map(r => Object.assign({}, r))\r\n\r\n    async getByKey(keys: Array<any>): Promise<Array<EntityType>> {\r\n        let rows = this.rows.filter(r => keys.includes(r.id))\r\n        return this.clone(rows)\r\n    }\r\n\r\n    async getSyncedSince(syncStamp?: Date): Promise<Array<EntityType>> {\r\n        let rows = this.rows.filter(r => !syncStamp || r.syncedAt && (r.syncedAt > syncStamp))\r\n        return this.clone(rows)\r\n    }\r\n\r\n    async update(entity: EntityType, syncStamp: Date, originalKey?: any): Promise<EntityType> {\r\n        let row = this.rows.find(r => r.id == (originalKey || entity.id))\r\n\r\n        if (!row) {\r\n            row = {} as EntityType\r\n            this.rows.push(row)\r\n        }\r\n\r\n        for(let key of Object.keys(entity) as Array<keyof EntityType>) {\r\n            row[key] = entity[key]\r\n        }\r\n\r\n        row.syncedAt = syncStamp\r\n\r\n        return Object.assign(row, {})\r\n    }\r\n\r\n    async add(entity: EntityType, syncStamp?: Date): Promise<EntityType> {\r\n        let row = Object.assign({}, entity)\r\n        row.syncedAt = syncStamp\r\n\r\n        while (this.rows.some(r => r.id == row.id)) {\r\n            row.id = this.newKey()\r\n        }\r\n\r\n        this.rows.push(row)\r\n\r\n        return Object.assign({}, row)\r\n    }\r\n\r\n    // client function\r\n    async getRequiringSync(): Promise<Array<EntityType>> {\r\n        let rows = this.rows.filter(r => !r.syncedAt || (r.updatedAt > r.syncedAt))\r\n        return this.clone(rows)\r\n    }\r\n\r\n    // client function\r\n    async MarkConflicted(serverEntity: EntityType): Promise<void> {\r\n        let entity = this.rows.find(r => r.id == serverEntity.id)\r\n\r\n        if (entity) entity.conflict = JSON.stringify(serverEntity)\r\n    }\r\n}\r\n","import React from 'react'\r\n\r\nexport interface ServerNoteProps {\r\n    noteText: string\r\n}\r\n\r\nexport const ServerNote = (props: ServerNoteProps) => {\r\n    return <div className='server-note'>{props.noteText}</div>\r\n}","import React, { Dispatch, ReducerAction, Reducer, useState, useEffect } from 'react'\r\nimport './Server.css'\r\n\r\nimport { LeanSyncServer, LeanSyncServerConfig } from 'leansync'\r\nimport { Note, NotesDatabase } from '../models/Note'\r\nimport { MockServer, MockNetwork, ActionType } from '../models/MockNetwork'\r\nimport { BASIC_CONFLICT_RESOLUTION_STRATEGIES, BasicConflictResolutionStrategy, SyncResponse } from 'leansync'\r\nimport { ServerNote } from './ServerNote'\r\n\r\nexport interface ServerProps extends MockServer {\r\n    dispatch: Dispatch<ReducerAction<Reducer<MockNetwork, ActionType>>>\r\n}\r\n\r\nexport const Server: React.FC<ServerProps> = (props) => {\r\n    let [serverNotes, setServerNotes] = useState([] as Array<Note>)\r\n\r\n    let noteComponents = serverNotes.map((note, ix) => {\r\n        return <ServerNote key={ix} noteText={note.text} />\r\n    })\r\n\r\n    let strategyOptions = BASIC_CONFLICT_RESOLUTION_STRATEGIES.map(strategy => <option value={strategy}>{strategy}</option>)\r\n\r\n    let changeStrategyHandler = (e: React.ChangeEvent<HTMLSelectElement>) => {\r\n        props.dispatch({ type: 'setResolutionStrategy', strategy: e.target.value as BasicConflictResolutionStrategy })\r\n    }\r\n\r\n    let addClient = () => props.dispatch({ type: 'addClient' })\r\n\r\n    useEffect(() => {\r\n\r\n        if (props.syncRequest) {\r\n            let serverDb = new NotesDatabase(serverNotes)\r\n\r\n            let serverConfig: LeanSyncServerConfig<Note> = {\r\n                entityKey: (note) => note.id,\r\n                entityLastUpdated: (note) => note.updatedAt,\r\n                areEntitiesEqual: (note1, note2) => note1.text == note2.text,\r\n                getServerEntities: serverDb.getByKey.bind(serverDb),\r\n                getServerEntitiesSyncedSince: serverDb.getSyncedSince.bind(serverDb),\r\n                updateServerEntity: serverDb.update.bind(serverDb),\r\n                createServerEntity: serverDb.add.bind(serverDb),\r\n                conflictResolutionStrategy: props.resolutionStrategy\r\n            }\r\n\r\n            let leanServer = new LeanSyncServer(serverConfig)\r\n\r\n            leanServer.sync(props.syncRequest.notes, props.syncRequest.lastSync)\r\n                .then(response => {\r\n                    setServerNotes(serverDb.rows)\r\n                    props.dispatch({ type: 'respondSync', response })\r\n                })\r\n                .catch(ex => { throw ex })\r\n        }\r\n\r\n    }, [props.syncRequest])\r\n\r\n    return (\r\n        <div className='computer server'>\r\n            <div className='computer-header'>\r\n                <h3 className='title is-3'>Server</h3>\r\n                <button className='button' onClick={addClient}>Add Client</button>\r\n            </div>\r\n\r\n            <div className='computer-wrapper server-wrapper'>\r\n                <div className='server-notes'>\r\n                    {noteComponents}\r\n                </div>\r\n\r\n                <div id='resolution-strategy'>\r\n                    <label>\r\n                        Conflict Resolution Strategy <br />\r\n                        <div className='select'>\r\n                            <select onChange={changeStrategyHandler}>\r\n                                {strategyOptions}\r\n                            </select>\r\n                        </div>\r\n                    </label>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Server\r\n\r\n","import React from 'react'\r\nimport classNames from 'classnames'\r\n\r\nexport interface ClientNoteProps {\r\n    noteText: string\r\n    // hasChanges: boolean\r\n    onChange: (val: string) => void\r\n}\r\n\r\nexport const ClientNote = (props: ClientNoteProps) => {\r\n    // let { hasChanges } = props\r\n    let className = classNames({ 'client-note': true }) //, hasChanges })\r\n\r\n    return (\r\n        <textarea\r\n            value={props.noteText}\r\n            onChange={(e) => props.onChange(e.target.value)}\r\n            className={className}\r\n        >\r\n        </textarea>\r\n    )\r\n}","import React, { useState, Dispatch, ReducerAction, Reducer, useRef, useEffect } from 'react'\r\nimport './Client.css'\r\n\r\nimport { LeanSyncClient, LeanSyncClientConfig, SyncResponse } from 'leansync'\r\nimport { MockClient, MockNetwork, ActionType, SyncRequest } from '../models/MockNetwork'\r\nimport { Note, newNote, NotesDatabase } from '../models/Note'\r\nimport { ClientNote } from './ClientNote'\r\n\r\nexport interface ClientProps extends MockClient {\r\n    clientIndex: number\r\n    dispatch: Dispatch<ReducerAction<Reducer<MockNetwork, ActionType>>>\r\n}\r\n\r\nexport const Client: React.FC<ClientProps> = (props) => {\r\n    let [lastSync, setLastSync] = useState<Date>()\r\n    let [clientNotes, setClientNotes] = useState([] as Array<Note>)\r\n\r\n\r\n    // TODO: refactor with NotesDatabase?\r\n    // TODO: add client note database & operations\r\n    let getNoteUpdateHandler = (noteIndex: number) => (noteText: string) => {\r\n        let updatedNotes = clientNotes.slice()\r\n\r\n        let updatedNote = { ...updatedNotes[noteIndex] }\r\n\r\n        updatedNote.text = noteText\r\n\r\n        updatedNotes[noteIndex] = updatedNote\r\n\r\n        setClientNotes(updatedNotes)\r\n    }\r\n\r\n    let noteComponents = clientNotes.map((note, ix) => {\r\n        return <ClientNote key={note.id} noteText={note.text} onChange={getNoteUpdateHandler(ix)} />\r\n    })\r\n\r\n    let addNote = () => {\r\n        let updatedNotes = clientNotes.slice()\r\n\r\n        updatedNotes.push(newNote(''))\r\n\r\n        setClientNotes(updatedNotes)\r\n    }\r\n\r\n    let toggleOffline = () => {\r\n        props.dispatch({ type: 'setClientOffline', clientIndex: props.clientIndex, isOffline: !props.isOffline })\r\n    }\r\n\r\n    let removeClient = () => {\r\n        props.dispatch({ type: 'removeClient', clientIndex: props.clientIndex })\r\n    }\r\n\r\n    let requestSync = () => {\r\n        let clientDb = new NotesDatabase(clientNotes)\r\n\r\n        let clientConfig: LeanSyncClientConfig<Note> = {\r\n            keySelector: (note) => note.id,\r\n            getClientEntitiesRequiringSync: clientDb.getRequiringSync.bind(clientDb),\r\n            getClientEntities: clientDb.getByKey.bind(clientDb),\r\n            getLastSyncStamp: async () => lastSync,\r\n            markSyncStamp: async (lastSync) => { setLastSync(lastSync) },\r\n            updateEntity: async (note, syncStamp, originalKey) => { clientDb.update(note, syncStamp, originalKey) },\r\n            createEntity: async (note, syncStamp) => { clientDb.add(note, syncStamp) },\r\n\r\n            syncWithServer: async (entities, lastSync) => {\r\n                let request: SyncRequest<Note> = {\r\n                    clientIndex: props.clientIndex,\r\n                    notes: entities,\r\n                    lastSync\r\n                }\r\n\r\n                props.dispatch({ type: 'requestSync', request })\r\n\r\n                let fakeResponse: SyncResponse<Note> = {\r\n                    newEntities: [],\r\n                    syncedEntities: [],\r\n                    conflictedEntities: [],\r\n                    syncStamp: new Date()\r\n                }\r\n\r\n                return Promise.resolve(fakeResponse)\r\n            },\r\n        }\r\n\r\n        let leanClient = new LeanSyncClient(clientConfig)\r\n\r\n        leanClient.sync()\r\n            .then(response => {\r\n                // this shouldn't matter\r\n                console.log(response)\r\n\r\n            })\r\n            .catch(ex => { throw console.log(ex) })\r\n    }\r\n\r\n    useEffect(() => {\r\n\r\n        if (props.syncResponse) {\r\n            let clientDb = new NotesDatabase(clientNotes)\r\n\r\n            let clientConfig: LeanSyncClientConfig<Note> = {\r\n                keySelector: (note) => note.id,\r\n                getClientEntitiesRequiringSync: clientDb.getRequiringSync.bind(clientDb),\r\n                getClientEntities: clientDb.getByKey.bind(clientDb),\r\n                getLastSyncStamp: async () => lastSync,\r\n                markSyncStamp: async (lastSync) => { setLastSync(lastSync) },\r\n                updateEntity: async (note, syncStamp, originalKey) => { clientDb.update(note, syncStamp, originalKey) },\r\n                createEntity: async (note, syncStamp) => { clientDb.add(note, syncStamp) },\r\n\r\n                syncWithServer: async (entities, lastSync) => {\r\n                    let request: SyncRequest<Note> = {\r\n                        clientIndex: props.clientIndex,\r\n                        notes: entities,\r\n                        lastSync\r\n                    }\r\n\r\n                    props.dispatch({ type: 'requestSync', request })\r\n\r\n                    let fakeResponse: SyncResponse<Note> = {\r\n                        newEntities: [],\r\n                        syncedEntities: [],\r\n                        conflictedEntities: [],\r\n                        syncStamp: new Date()\r\n                    }\r\n\r\n                    return Promise.resolve(fakeResponse)\r\n                },\r\n            }\r\n\r\n            let leanClient = new LeanSyncClient(clientConfig)\r\n\r\n            leanClient.processSyncResponse(props.syncResponse)\r\n\r\n            setClientNotes(clientDb.rows)\r\n            props.dispatch({ type: 'acknowledgeSync', clientIndex: props.clientIndex })\r\n        }\r\n\r\n    }, [props.syncResponse])\r\n\r\n    return (\r\n        <div className='computer client'>\r\n            <div className='computer-header'>\r\n                <h2 className='title is-3'>\r\n                    <a className='remove' title='Remove Client' onClick={removeClient}></a>\r\n                    Client\r\n                </h2>\r\n                <label className='offline checkbox'>\r\n                    <input type='checkbox' onClick={toggleOffline} />\r\n                    Offline\r\n                </label>\r\n            </div>\r\n            <div className='computer-wrapper client-wrapper'>\r\n                <div className='client-notes'>\r\n                    {noteComponents}\r\n                </div>\r\n                <div className='client buttons are-small'>\r\n                    <button title='Add Note' className='new button is-success is-outlined' onClick={addNote}><span /></button>\r\n                    <button title='Sync Notes' className='sync button is-link is-outlined' onClick={requestSync}><span /></button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Client\r\n","import { Note, NotesDatabase, newNote } from './Note'\r\nimport { BasicConflictResolutionStrategy, LeanSyncServer, LeanSyncServerConfig, SyncResponse } from 'leansync'\r\nimport { LeanSyncClient, LeanSyncClientConfig } from 'leansync'\r\nimport { assertNever } from '../utility'\r\n\r\nexport interface SyncRequest<T> {\r\n    clientIndex: number\r\n    notes: Array<T>\r\n    lastSync?: Date\r\n}\r\n\r\nexport interface MockServer {\r\n    resolutionStrategy: BasicConflictResolutionStrategy\r\n    syncRequest?: SyncRequest<Note>\r\n}\r\n\r\nexport interface MockClient {\r\n    isOffline?: boolean\r\n    syncResponse?: SyncResponse<Note>\r\n}\r\n\r\nexport interface MockNetwork {\r\n    server: MockServer\r\n    clients: Array<MockClient>\r\n}\r\n\r\nexport const initialNetwork: MockNetwork = {\r\n    server: { resolutionStrategy: 'takeClient' },\r\n    clients: [],\r\n}\r\n\r\ninterface SetResolutionStrategyAction {\r\n    type: 'setResolutionStrategy'\r\n    strategy: BasicConflictResolutionStrategy\r\n}\r\n\r\nfunction setResolutionStrategy(network: MockNetwork, resolutionStrategy: BasicConflictResolutionStrategy): MockNetwork {\r\n    let nw = { ...network }\r\n\r\n    nw.server = { ...network.server, resolutionStrategy }\r\n\r\n    return nw\r\n}\r\n\r\ninterface AddClientAction {\r\n    type: 'addClient'\r\n}\r\n\r\nfunction addClient(network: MockNetwork): MockNetwork {\r\n    let nw = { ...network }\r\n\r\n    nw.clients = network.clients.slice()\r\n    nw.clients.push({})\r\n\r\n    return nw\r\n}\r\n\r\ninterface RemoveClientAction {\r\n    type: 'removeClient'\r\n    clientIndex: number\r\n}\r\n\r\nfunction removeClient(network: MockNetwork, clientIndex: number): MockNetwork {\r\n    let nw = { ...network }\r\n\r\n    nw.clients = network.clients.slice()\r\n    nw.clients.splice(clientIndex, 1)\r\n\r\n    return nw\r\n}\r\n\r\ninterface SetClientOfflineAction {\r\n    type: 'setClientOffline'\r\n    clientIndex: number\r\n    isOffline: boolean\r\n}\r\n\r\nfunction setClientOffline(network: MockNetwork, clientIndex: number, isOffline: boolean): MockNetwork {\r\n    let nw = { ...network }\r\n\r\n    nw.clients = network.clients.slice()\r\n    nw.clients[clientIndex] = { ...network.clients[clientIndex], isOffline }\r\n\r\n    return nw\r\n}\r\n\r\ninterface RequestSyncAction  {\r\n    type: 'requestSync'\r\n    request: SyncRequest<Note>\r\n}\r\n\r\nfunction requestSync(network: MockNetwork, syncRequest: SyncRequest<Note>): MockNetwork {\r\n    let nw = { ...network }\r\n\r\n    let server = { ...nw.server }\r\n    server.syncRequest = syncRequest\r\n\r\n    nw.server = server\r\n\r\n    return nw\r\n}\r\n\r\ninterface RespondSyncAction {\r\n    type: 'respondSync'\r\n    response: SyncResponse<Note>\r\n}\r\n\r\nexport function respondSync(network: MockNetwork, syncResponse: SyncResponse<Note>): MockNetwork {\r\n    // this shouldn't happen, but does.  TODO: investigate double rendering\r\n    if (!network.server.syncRequest) return network \r\n\r\n    let nw = { ...network }\r\n\r\n    let clientIndex = nw.server.syncRequest!.clientIndex\r\n\r\n    let server = { ...nw.server }\r\n    delete server.syncRequest\r\n    nw.server = server\r\n\r\n    nw.clients = nw.clients.slice()\r\n    let client = { ...nw.clients[clientIndex] }\r\n    client.syncResponse = syncResponse\r\n\r\n    nw.clients[clientIndex] = client\r\n\r\n    return nw\r\n}\r\n\r\nexport interface AcknowledgeSyncAction {\r\n    type: 'acknowledgeSync'\r\n    clientIndex: number\r\n}\r\n\r\nexport function acknowledgeSync(network: MockNetwork, clientIndex: number): MockNetwork {\r\n    let nw = { ...network }\r\n\r\n    nw.clients = nw.clients.slice()\r\n    let client = { ...nw.clients[clientIndex] }\r\n    delete client.syncResponse\r\n\r\n    nw.clients[clientIndex] = client\r\n\r\n    return nw\r\n}\r\n\r\nexport type ActionType = \r\n    SetResolutionStrategyAction | \r\n    AddClientAction | \r\n    RemoveClientAction | \r\n    SetClientOfflineAction | \r\n    RequestSyncAction | \r\n    RespondSyncAction |\r\n    AcknowledgeSyncAction\r\n\r\nexport function mockNetworkReducer(network: MockNetwork, action: ActionType ): MockNetwork {\r\n    let modifiedNetwork: MockNetwork\r\n\r\n    switch(action.type) {\r\n        case 'setResolutionStrategy': \r\n            modifiedNetwork = setResolutionStrategy(network, action.strategy) \r\n            break\r\n        case 'addClient': \r\n            modifiedNetwork = addClient(network) \r\n            break\r\n        case 'removeClient': \r\n            modifiedNetwork = removeClient(network, action.clientIndex) \r\n            break\r\n        case 'setClientOffline': \r\n            modifiedNetwork = setClientOffline(network, action.clientIndex, action.isOffline) \r\n            break\r\n        case 'requestSync': \r\n            modifiedNetwork = requestSync(network, action.request) \r\n            break\r\n        case 'respondSync': \r\n            modifiedNetwork = respondSync(network, action.response)\r\n            break\r\n        case 'acknowledgeSync': \r\n            modifiedNetwork = acknowledgeSync(network, action.clientIndex)\r\n            break\r\n        default: assertNever(action)\r\n    }\r\n\r\n    return modifiedNetwork\r\n}\r\n","export function assertNever(val: any): never {\r\n    throw new Error('Unexpected object: ' + val)\r\n}","import React, { useReducer, useEffect } from 'react'\r\nimport './Network.css'\r\n\r\nimport { Server } from './Server'\r\nimport { Client } from './Client'\r\n\r\nimport { mockNetworkReducer, initialNetwork } from '../models/MockNetwork'\r\n\r\n\r\nexport const Network = () => {\r\n\r\n    const [mockNetwork, dispatch] = useReducer(mockNetworkReducer, initialNetwork)\r\n\r\n    let clients = mockNetwork.clients.map((client, ix) => {\r\n        return <Client key={ix} clientIndex={ix} isOffline={client.isOffline} dispatch={dispatch} syncResponse={client.syncResponse} />\r\n    })\r\n\r\n    return (\r\n        <div>\r\n            <div className='computers'>\r\n                <Server resolutionStrategy={mockNetwork.server.resolutionStrategy} syncRequest={mockNetwork.server.syncRequest} dispatch={dispatch} />\r\n                {clients}\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Network\r\n","import React from 'react'\nimport 'bulma/css/bulma.css'\nimport './App.css'\n\nimport { Header } from './components/Header'\n\nimport { Network } from './components/Network'\n\nconst App = () => {\n  return (\n    <div className=\"App\">\n        <Header />\n        <Network />\n    </div>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}