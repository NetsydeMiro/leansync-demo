{"version":3,"sources":["components/ServerNote.tsx","components/Server.tsx","models/Note.ts","models/MockSyncedTable.ts","components/ClientNote.tsx","components/Client.tsx","models/MockNetwork.ts","utility.ts","components/Network.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["ServerNote","props","className","noteText","Server","noteComponents","notes","map","note","ix","key","text","strategyOptions","BASIC_CONFLICT_RESOLUTION_STRATEGIES","strategy","value","onChange","e","dispatch","type","target","newNote","updatedAt","Date","id","v1","toString","NotesDatabase","numberOfNotes","syncedAt","db","add","rows","newKey","clone","r","Object","assign","this","keys","filter","includes","syncStamp","entity","originalKey","row","find","push","some","serverEntity","conflict","JSON","stringify","ClientNote","hasChanges","classNames","Client","useState","clientNotes","setNotes","noteIndex","originalNote","length","updatedNotes","slice","updatedNote","title","onClick","clientIndex","String","fromCharCode","isOffline","initialNetwork","server","resolutionStrategy","clients","mockNetworkReducer","network","action","modifiedNetwork","nw","setResolutionStrategy","addClient","splice","removeClient","setClientOffline","syncRequest","requestSync","serverNotes","updatedClient","lastSync","processSync","val","Error","assertNever","Network","useReducer","mockNetwork","useEffect","a","async","serverDb","clientDb","serverConfig","entityKey","entityLastUpdated","areEntitiesEqual","note1","note2","getServerEntities","getByKey","getServerEntitiesSyncedSince","getSyncedSince","updateServerEntity","clientEntity","update","createServerEntity","conflictResolutionStrategy","leanServer","LeanSyncServer","client","clientConfig","keySelector","getClientEntitiesRequiringSync","getRequiringSync","bind","getClientEntities","getLastSyncStamp","markSyncStamp","updateEntity","createEntity","syncWithServer","entities","sync","leanClient","LeanSyncClient","doSync","then","processSyncAction","catch","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.92022539.chunk.js","sourcesContent":["import React from 'react'\r\n\r\nexport interface ServerNoteProps {\r\n    noteText: string\r\n}\r\n\r\nexport const ServerNote = (props: ServerNoteProps) => {\r\n    return <div className='server-note'>{props.noteText}</div>\r\n}","import React, { Dispatch, ReducerAction, Reducer } from 'react'\r\nimport './Server.css'\r\n\r\nimport { MockServer, MockNetwork, ActionType } from '../models/MockNetwork'\r\nimport { BASIC_CONFLICT_RESOLUTION_STRATEGIES, BasicConflictResolutionStrategy } from 'leansync'\r\nimport { ServerNote } from './ServerNote'\r\n\r\nexport interface ServerProps extends MockServer {\r\n    dispatch: Dispatch<ReducerAction<Reducer<MockNetwork, ActionType>>>\r\n}\r\n\r\nexport const Server: React.FC<ServerProps> = (props) => {\r\n\r\n    let noteComponents = props.notes.map((note, ix) => {\r\n        return <ServerNote key={ix} noteText={note.text} />\r\n    })\r\n\r\n    let strategyOptions = BASIC_CONFLICT_RESOLUTION_STRATEGIES.map(strategy => <option value={strategy}>{strategy}</option>)\r\n\r\n    let changeStrategyHandler = (e: React.ChangeEvent<HTMLSelectElement>) => {\r\n        props.dispatch({ type: 'setResolutionStrategy', strategy: e.target.value as BasicConflictResolutionStrategy })\r\n    }\r\n\r\n    return (\r\n        <div className='computer server'>\r\n            <h2 className='computer-header'>Server</h2>\r\n            <label>\r\n                Conflict Resolution Strategy\r\n                <select onChange={changeStrategyHandler}>\r\n                    {strategyOptions}\r\n                </select>\r\n            </label>\r\n            <div className='computer-wrapper server-wrapper'>\r\n                <div className='server-notes'>\r\n                    {noteComponents}\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Server\r\n\r\n","import { v1 } from 'uuid'\r\n\r\nimport { MockSyncedTable } from './MockSyncedTable'\r\n\r\nexport interface Note {\r\n    id: string\r\n    text: string\r\n    updatedAt: Date\r\n    syncedAt?: Date\r\n}\r\n\r\nexport function newNote(text: string, updatedAt: Date = new Date()): Note {\r\n    return { id: v1().toString(), text, updatedAt }\r\n}\r\n\r\nexport class NotesDatabase extends MockSyncedTable<Note> {\r\n\r\n    static createPopulated(numberOfNotes: number, syncedAt: Date): NotesDatabase {\r\n        let db = new NotesDatabase()\r\n\r\n        for (let ix = 1; ix <= numberOfNotes; ix++) {\r\n            db.add(newNote(`Note ${ix}`, syncedAt), syncedAt)\r\n        }\r\n        return db\r\n    }\r\n}","import { v1 } from 'uuid'\r\n\r\nexport interface Entity {\r\n    id: any\r\n    updatedAt: Date\r\n    syncedAt?: Date\r\n    conflict?: string\r\n}\r\n\r\nexport interface KeyGenerator {\r\n    (): any\r\n}\r\n\r\n// TODO: refactor as dictionary instead of array of rows?\r\nexport class MockSyncedTable<EntityType extends Entity> {\r\n\r\n    constructor(\r\n        rows: Array<EntityType> = [],\r\n        public newKey: KeyGenerator = () => v1().toString()) {\r\n        this.rows = this.clone(rows)\r\n    }\r\n\r\n    rows: Array<EntityType>\r\n\r\n    protected clone = (rows: Array<EntityType>) => rows.map(r => Object.assign({}, r))\r\n\r\n    async getByKey(keys: Array<any>): Promise<Array<EntityType>> {\r\n        let rows = this.rows.filter(r => keys.includes(r.id))\r\n        return this.clone(rows)\r\n    }\r\n\r\n    async getSyncedSince(syncStamp?: Date): Promise<Array<EntityType>> {\r\n        let rows = this.rows.filter(r => !syncStamp || r.syncedAt && (r.syncedAt > syncStamp))\r\n        return this.clone(rows)\r\n    }\r\n\r\n    async update(entity: EntityType, syncStamp: Date, originalKey?: any): Promise<EntityType> {\r\n        let row = this.rows.find(r => r.id == (originalKey || entity.id))\r\n\r\n        if (!row) {\r\n            row = {} as EntityType\r\n            this.rows.push(row)\r\n        }\r\n\r\n        for(let key of Object.keys(entity) as Array<keyof EntityType>) {\r\n            row[key] = entity[key]\r\n        }\r\n\r\n        row.syncedAt = syncStamp\r\n\r\n        return Object.assign(row, {})\r\n    }\r\n\r\n    async add(entity: EntityType, syncStamp?: Date): Promise<EntityType> {\r\n        let row = Object.assign({}, entity)\r\n        row.syncedAt = syncStamp\r\n\r\n        while (this.rows.some(r => r.id == row.id)) {\r\n            row.id = this.newKey()\r\n        }\r\n\r\n        this.rows.push(row)\r\n\r\n        return Object.assign({}, row)\r\n    }\r\n\r\n    // client function\r\n    async getRequiringSync(): Promise<Array<EntityType>> {\r\n        let rows = this.rows.filter(r => !r.syncedAt || r.updatedAt > r.syncedAt)\r\n        return this.clone(rows)\r\n    }\r\n\r\n    // client function\r\n    async MarkConflicted(serverEntity: EntityType): Promise<void> {\r\n        let entity = this.rows.find(r => r.id == serverEntity.id)\r\n\r\n        if (entity) entity.conflict = JSON.stringify(serverEntity)\r\n    }\r\n}\r\n","import React from 'react'\r\nimport classNames from 'classnames'\r\n\r\nexport interface ClientNoteProps {\r\n    noteText: string\r\n    hasChanges: boolean\r\n    onChange: (val: string) => void\r\n}\r\n\r\nexport const ClientNote = (props: ClientNoteProps) => {\r\n    let { hasChanges } = props\r\n    let className = classNames({ 'client-note': true, hasChanges })\r\n\r\n    return (\r\n        <textarea\r\n            value={props.noteText}\r\n            onChange={(e) => props.onChange(e.target.value)}\r\n            className={className}\r\n        >\r\n        </textarea>\r\n    )\r\n}","import React, { useState, Dispatch, ReducerAction, Reducer } from 'react'\r\nimport './Client.css'\r\n\r\nimport { MockClient, MockNetwork, ActionType } from '../models/MockNetwork'\r\nimport { Note, newNote } from '../models/Note'\r\nimport { ClientNote } from './ClientNote'\r\n\r\nexport interface ClientProps extends MockClient {\r\n    clientIndex: number\r\n    dispatch: Dispatch<ReducerAction<Reducer<MockNetwork, ActionType>>>\r\n}\r\n\r\nexport const Client: React.FC<ClientProps> = (props) => {\r\n    let [clientNotes, setNotes] = useState(props.notes)\r\n\r\n    // TODO: refactor with NotesDatabase?\r\n    // TODO: add client note database & operations\r\n    let getNoteUpdateHandler = (noteIndex: number) => (noteText: string) => {\r\n        let updatedNotes = clientNotes.slice()\r\n\r\n        let updatedNote = { ...updatedNotes[noteIndex] }\r\n\r\n        updatedNote.text = noteText\r\n\r\n        updatedNotes[noteIndex] = updatedNote\r\n\r\n        setNotes(updatedNotes)\r\n    }\r\n\r\n    let noteComponents = clientNotes.map((note, ix) => {\r\n        let originalNote = (props.notes.length > ix) && props.notes[ix]\r\n        let hasChanges = !originalNote || note.text != originalNote.text\r\n        return <ClientNote key={note.id} noteText={note.text} hasChanges={hasChanges} onChange={getNoteUpdateHandler(ix)} />\r\n    })\r\n\r\n    let addNote = () => {\r\n        let updatedNotes = clientNotes.slice()\r\n\r\n        updatedNotes.push(newNote(''))\r\n\r\n        setNotes(updatedNotes)\r\n    }\r\n\r\n    let toggleOffline = () => {\r\n        props.dispatch({ type: 'setClientOffline', clientIndex: props.clientIndex, isOffline: !props.isOffline })\r\n    }\r\n\r\n    let removeClient = () => {\r\n        props.dispatch({ type: 'removeClient', clientIndex: props.clientIndex })\r\n    }\r\n\r\n    let requestSync = () => {\r\n        props.dispatch({ type: 'requestSync', clientIndex: props.clientIndex, clientNotes })\r\n    }\r\n\r\n    return (\r\n        <div className='computer client'>\r\n            <h2 className='computer-header'>\r\n                Client \r\n                <a className='remove' title='Remove Client' onClick={removeClient}>{String.fromCharCode(10008)}</a>\r\n            </h2>\r\n            <label>\r\n                <input type='checkbox' onClick={toggleOffline} />\r\n                Is Offline\r\n            </label>\r\n            <div className='computer-wrapper client-wrapper'>\r\n                <div className='client-notes'>\r\n                    {noteComponents}\r\n                </div>\r\n                <div className='client-buttons'>\r\n                    <button onClick={addNote}>New</button>\r\n                    <button onClick={requestSync}>Sync</button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Client\r\n","import { Note, NotesDatabase, newNote } from './Note'\r\nimport { BasicConflictResolutionStrategy, LeanSyncServer, LeanSyncServerConfig } from 'leansync'\r\nimport { LeanSyncClient, LeanSyncClientConfig } from 'leansync'\r\nimport { assertNever } from '../utility'\r\n\r\nexport interface MockServer {\r\n    notes:  Array<Note>\r\n    resolutionStrategy: BasicConflictResolutionStrategy\r\n}\r\n\r\nexport interface MockClient {\r\n    notes: Array<Note>\r\n    lastSync?: Date\r\n    isOffline?: boolean\r\n}\r\n\r\nexport interface SyncRequest {\r\n    clientIndex: number\r\n    clientNotes: Array<Note>\r\n}\r\n\r\nexport interface SyncResult {\r\n    clientNotes: Array<Note>\r\n    serverNotes: Array<Note>\r\n}\r\n\r\nexport interface MockNetwork {\r\n    server: MockServer\r\n    clients: Array<MockClient>\r\n    syncRequest?: SyncRequest\r\n}\r\n\r\nexport const initialNetwork: MockNetwork = {\r\n    server: { notes: [], resolutionStrategy: 'takeClient' },\r\n    clients: [],\r\n}\r\n\r\ninterface SetResolutionStrategyAction {\r\n    type: 'setResolutionStrategy'\r\n    strategy: BasicConflictResolutionStrategy\r\n}\r\n\r\nfunction setResolutionStrategy(network: MockNetwork, resolutionStrategy: BasicConflictResolutionStrategy): MockNetwork {\r\n    let nw = { ...network }\r\n\r\n    nw.server = { ...network.server, resolutionStrategy }\r\n\r\n    return nw\r\n}\r\n\r\ninterface AddClientAction {\r\n    type: 'addClient'\r\n}\r\n\r\nfunction addClient(network: MockNetwork): MockNetwork {\r\n    let nw = { ...network }\r\n\r\n    nw.clients = network.clients.slice()\r\n    nw.clients.push({ notes: [] })\r\n\r\n    return nw\r\n}\r\n\r\ninterface RemoveClientAction {\r\n    type: 'removeClient'\r\n    clientIndex: number\r\n}\r\n\r\nfunction removeClient(network: MockNetwork, clientIndex: number): MockNetwork {\r\n    let nw = { ...network }\r\n\r\n    nw.clients = network.clients.slice()\r\n    nw.clients.splice(clientIndex, 1)\r\n\r\n    return nw\r\n}\r\n\r\ninterface SetClientOfflineAction {\r\n    type: 'setClientOffline'\r\n    clientIndex: number\r\n    isOffline: boolean\r\n}\r\n\r\nfunction setClientOffline(network: MockNetwork, clientIndex: number, isOffline: boolean): MockNetwork {\r\n    let nw = { ...network }\r\n\r\n    nw.clients = network.clients.slice()\r\n    nw.clients[clientIndex] = { ...network.clients[clientIndex], isOffline }\r\n\r\n    return nw\r\n}\r\n\r\ninterface RequestSyncAction {\r\n    type: 'requestSync'\r\n    clientIndex: number\r\n    clientNotes: Array<Note>\r\n}\r\n\r\nfunction requestSync(network: MockNetwork, clientIndex: number, clientNotes: Array<Note>): MockNetwork {\r\n    let nw = { ...network }\r\n\r\n    let syncRequest: SyncRequest = {\r\n        clientIndex, \r\n        clientNotes\r\n    }\r\n\r\n    nw.syncRequest = syncRequest\r\n\r\n    return nw\r\n}\r\n\r\ninterface ProcessSyncAction {\r\n    type: 'processSync'\r\n    clientIndex: number\r\n    clientNotes: Array<Note>\r\n    serverNotes: Array<Note>\r\n    syncStamp: Date\r\n}\r\n\r\nfunction processSync(network: MockNetwork, clientIndex: number, clientNotes: Array<Note>, serverNotes: Array<Note>, syncStamp: Date): MockNetwork {\r\n    let nw = { ...network }\r\n\r\n    let server = { ...nw.server }\r\n    server.notes = serverNotes\r\n\r\n    let clients = nw.clients.slice()\r\n    let updatedClient = { ...clients[clientIndex] }\r\n\r\n    updatedClient.notes = clientNotes\r\n    updatedClient.lastSync = syncStamp\r\n    clients[clientIndex] = updatedClient\r\n\r\n    nw.clients = clients\r\n    nw.server = server\r\n\r\n    delete nw.syncRequest\r\n\r\n    return nw\r\n}\r\n\r\nexport type ActionType = \r\n    SetResolutionStrategyAction | \r\n    AddClientAction | \r\n    RemoveClientAction | \r\n    SetClientOfflineAction | \r\n    RequestSyncAction | \r\n    ProcessSyncAction \r\n\r\nexport function mockNetworkReducer(network: MockNetwork, action: ActionType ): MockNetwork {\r\n    let modifiedNetwork: MockNetwork\r\n\r\n    switch(action.type) {\r\n        case 'setResolutionStrategy': \r\n            modifiedNetwork = setResolutionStrategy(network, action.strategy) \r\n            break\r\n        case 'addClient': \r\n            modifiedNetwork = addClient(network) \r\n            break\r\n        case 'removeClient': \r\n            modifiedNetwork = removeClient(network, action.clientIndex) \r\n            break\r\n        case 'setClientOffline': \r\n            modifiedNetwork = setClientOffline(network, action.clientIndex, action.isOffline) \r\n            break\r\n        case 'requestSync': \r\n            modifiedNetwork = requestSync(network, action.clientIndex, action.clientNotes) \r\n            break\r\n        case 'processSync': \r\n            modifiedNetwork = processSync(network, action.clientIndex, action.clientNotes, action.serverNotes, action.syncStamp) \r\n            break\r\n        default: assertNever(action)\r\n    }\r\n\r\n    return modifiedNetwork\r\n}\r\n\r\nexport async function doSync(network: MockNetwork, clientIndex: number, clientNotes: Array<Note>): Promise<ProcessSyncAction> {\r\n    let serverDb = new NotesDatabase(network.server.notes)\r\n    let clientDb = new NotesDatabase(clientNotes)\r\n\r\n    let serverConfig: LeanSyncServerConfig<Note> = {\r\n        entityKey: (note) => note.id,\r\n        entityLastUpdated: (note) => note.updatedAt, \r\n        areEntitiesEqual: (note1, note2) => note1.text == note2.text, \r\n        getServerEntities: (keys) => serverDb.getByKey(keys), \r\n        getServerEntitiesSyncedSince: (syncStamp) => serverDb.getSyncedSince(syncStamp), \r\n        updateServerEntity: (clientEntity, syncStamp) => serverDb.update(clientEntity, syncStamp), \r\n        createServerEntity: (clientEntity, syncStamp) => serverDb.add(clientEntity, syncStamp), \r\n        conflictResolutionStrategy: network.server.resolutionStrategy\r\n    }\r\n\r\n    let leanServer = new LeanSyncServer(serverConfig)\r\n\r\n    let client = network.clients[clientIndex]\r\n\r\n    // we'll record the sync stamp here\r\n    let syncStamp = new Date()\r\n\r\n    let clientConfig: LeanSyncClientConfig<Note> = {\r\n        keySelector: (note) => note.id,\r\n        getClientEntitiesRequiringSync: clientDb.getRequiringSync.bind(clientDb),\r\n        getClientEntities: clientDb.getByKey,\r\n        getLastSyncStamp: async () => client.lastSync,\r\n        markSyncStamp: async (lastSync) => { syncStamp = lastSync },\r\n        updateEntity: async (note, syncStamp, originalKey) => { clientDb.update(note, syncStamp, originalKey) },\r\n        createEntity: async (note) => { clientDb.add(note) },\r\n        syncWithServer: async (entities, lastSync) => {\r\n            return leanServer.sync(entities, lastSync)\r\n        },\r\n    }\r\n\r\n    let leanClient = new LeanSyncClient(clientConfig)\r\n\r\n    await leanClient.sync()\r\n\r\n    let action: ProcessSyncAction = {\r\n        type: \"processSync\", \r\n        clientIndex, \r\n        serverNotes: serverDb.rows, \r\n        clientNotes: clientDb.rows, \r\n        syncStamp\r\n    }\r\n\r\n    return action\r\n}\r\n","export function assertNever(val: any): never {\r\n    throw new Error('Unexpected object: ' + val)\r\n}","import React, { useReducer, useEffect } from 'react'\r\nimport './Network.css'\r\n\r\nimport { Server } from './Server'\r\nimport { Client } from './Client'\r\n\r\nimport { mockNetworkReducer, initialNetwork, doSync } from '../models/MockNetwork'\r\n\r\n\r\nexport const Network = () => {\r\n\r\n    const [mockNetwork, dispatch] = useReducer(mockNetworkReducer, initialNetwork)\r\n\r\n    useEffect(() => {\r\n        if (!!mockNetwork.syncRequest) {\r\n            doSync(mockNetwork, mockNetwork.syncRequest.clientIndex, mockNetwork.syncRequest.clientNotes)\r\n                .then(processSyncAction => dispatch(processSyncAction))\r\n                .catch(e => { throw e })\r\n        }\r\n    })\r\n\r\n    let clients = mockNetwork.clients.map((client, ix) => {\r\n        return <Client key={ix} clientIndex={ix} notes={client.notes} dispatch={dispatch} />\r\n    })\r\n\r\n    let addClient = () => dispatch({ type: 'addClient' })\r\n\r\n    return (\r\n        <div>\r\n            <div className='computers'>\r\n                <Server notes={mockNetwork.server.notes} resolutionStrategy={mockNetwork.server.resolutionStrategy} dispatch={dispatch} />\r\n                {clients}\r\n            </div>\r\n            <button onClick={addClient}>Add Client</button>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Network\r\n","import React from 'react'\nimport logo from './logo.svg'\nimport './App.css'\n\nimport { Network } from './components/Network'\n\nconst App = () => {\n  return (\n    <div className=\"App\">\n        <Network />\n    </div>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}